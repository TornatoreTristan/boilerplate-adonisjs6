# 🌍 Internationalization (i18n)

> Système multi-langue français/anglais avec AdonisJS I18n + React i18next

## 📋 Table des matières

- [Vue d'ensemble](#vue-densemble)
- [Architecture](#architecture)
- [Backend (AdonisJS)](#backend-adonisjs)
- [Frontend (React)](#frontend-react)
- [Champs traduisibles en base](#champs-traduisibles-en-base)
- [Full-Text Search multi-langue](#full-text-search-multi-langue)
- [Utilisation](#utilisation)

## Vue d'ensemble

Le boilerplate supporte 2 langues :
- **Français** (défaut)
- **Anglais**

### Deux systèmes complémentaires

1. **AdonisJS I18n** : Pour les textes statiques de l'interface (labels, messages d'erreur)
2. **Champs JSON traduisibles** : Pour le contenu dynamique créé par les utilisateurs

## Architecture

```
Backend (AdonisJS)
├── config/i18n.ts              # Configuration i18n
├── resources/lang/
│   ├── fr/                     # Traductions françaises
│   │   ├── common.json
│   │   └── auth.json
│   └── en/                     # Traductions anglaises
│       ├── common.json
│       └── auth.json
├── app/middleware/detect_user_locale_middleware.ts
├── app/shared/helpers/translatable.ts
└── app/shared/services/locale_service.ts

Frontend (React)
├── inertia/lib/i18n.ts         # Configuration react-i18next
├── inertia/lib/translatable.ts # Helper pour champs traduisibles
└── inertia/components/core/language-selector.tsx
```

## Backend (AdonisJS)

### Configuration

```typescript
// config/i18n.ts
const i18nConfig = defineConfig({
  defaultLocale: 'fr',
  supportedLocales: ['fr', 'en'],
  formatter: formatters.icu(),
  fallbackLocales: {
    en: 'fr',
  },
  loaders: [
    loaders.fs({
      location: app.languageFilesPath()
    }),
  ],
})
```

### Détection automatique de la langue

Le middleware détecte la langue dans cet ordre :
1. **Query parameter** : `?locale=en`
2. **Cookie** : `locale=en`
3. **Accept-Language header** : Navigateur

```typescript
// app/middleware/detect_user_locale_middleware.ts
protected getRequestLocale(ctx: HttpContext) {
  // 1. Query param
  const localeFromQuery = ctx.request.input('locale')
  if (localeFromQuery && i18nManager.supportedLocales().includes(localeFromQuery)) {
    return localeFromQuery
  }

  // 2. Cookie
  const localeFromCookie = ctx.request.cookie('locale')
  if (localeFromCookie && i18nManager.supportedLocales().includes(localeFromCookie)) {
    return localeFromCookie
  }

  // 3. Accept-Language
  const userLanguages = ctx.request.languages()
  return i18nManager.getSupportedLocaleFor(userLanguages)
}
```

### Utilisation dans les controllers

```typescript
export default class UsersController {
  async index({ i18n }: HttpContext) {
    const welcomeMessage = i18n.t('common.welcome')
    const loginText = i18n.t('auth.login')

    return { welcomeMessage, loginText }
  }
}
```

### LocaleService injectable

```typescript
import { inject } from 'inversify'
import { TYPES } from '#shared/container/types'
import LocaleService from '#shared/services/locale_service'

@injectable()
export default class MyService {
  constructor(
    @inject(TYPES.LocaleService) private localeService: LocaleService
  ) {}

  doSomething() {
    const currentLocale = this.localeService.getCurrentLocale()
    // 'fr' ou 'en'
  }
}
```

## Frontend (React)

### Configuration

```typescript
// inertia/lib/i18n.ts
import i18n from 'i18next'
import { initReactI18next } from 'react-i18next'
import LanguageDetector from 'i18next-browser-languagedetector'

i18n
  .use(LanguageDetector)
  .use(initReactI18next)
  .init({
    resources: {
      fr: { common: {...}, auth: {...} },
      en: { common: {...}, auth: {...} }
    },
    fallbackLng: 'fr',
    supportedLngs: ['fr', 'en'],
    defaultNS: 'common',
    detection: {
      order: ['querystring', 'cookie', 'localStorage', 'navigator'],
      caches: ['cookie', 'localStorage'],
    },
  })
```

### Utilisation dans les composants

```tsx
import { useTranslation } from 'react-i18next'

export function MyComponent() {
  const { t, i18n } = useTranslation()

  return (
    <div>
      <h1>{t('common.welcome')}</h1>
      <p>{t('auth.login')}</p>
      <p>Current language: {i18n.language}</p>
    </div>
  )
}
```

### Sélecteur de langue

Le composant `<LanguageSelector />` est déjà intégré dans `app-layout.tsx` :

```tsx
import { LanguageSelector } from '@/components/core/language-selector'

<LanguageSelector />
```

Permet de changer la langue avec drapeaux 🇫🇷 🇬🇧

## Champs traduisibles en base

Pour le contenu dynamique (plans, descriptions, notifications), nous utilisons des colonnes JSON `_i18n`.

### Type TranslatableField

```typescript
export type TranslatableField = {
  fr: string
  en: string
}

export type TranslatableFieldNullable = {
  fr?: string | null
  en?: string | null
}
```

### Tables concernées

| Table | Champs traduisibles |
|-------|---------------------|
| `plans` | `name_i18n`, `description_i18n`, `features_i18n` |
| `organizations` | `description_i18n` |
| `notifications` | `title_i18n`, `message_i18n` |

### Migration

```typescript
// Exemple: Plans table
table.jsonb('name_i18n').notNullable()
table.jsonb('description_i18n').nullable()
table.jsonb('features_i18n').nullable()

// Données stockées:
{
  name_i18n: { fr: "Plan Pro", en: "Pro Plan" },
  description_i18n: { fr: "Pour les équipes", en: "For teams" }
}
```

### Modèle Lucid

```typescript
import type { TranslatableField, TranslatableFieldNullable } from '#shared/helpers/translatable'

export default class Plan extends BaseModel {
  @column({
    prepare: (value: TranslatableField) => JSON.stringify(value),
    consume: (value: string | TranslatableField) =>
      typeof value === 'string' ? JSON.parse(value) : value,
  })
  declare nameI18n: TranslatableField

  @column({
    prepare: (value: TranslatableFieldNullable | null) =>
      value ? JSON.stringify(value) : null,
    consume: (value: string | TranslatableFieldNullable | null) => {
      if (value === null) return null
      return typeof value === 'string' ? JSON.parse(value) : value
    },
  })
  declare descriptionI18n: TranslatableFieldNullable | null
}
```

### Utilisation Backend

```typescript
import { getTranslation } from '#shared/helpers/translatable'

// Créer un plan
const plan = await planRepository.create({
  nameI18n: { fr: 'Pro', en: 'Pro' },
  descriptionI18n: { fr: 'Plan professionnel', en: 'Professional plan' },
  // ...
})

// Récupérer traduction
const locale = localeService.getCurrentLocale()
const name = getTranslation(plan.nameI18n, locale)
// Si locale = 'fr' => 'Pro'
// Si locale = 'en' => 'Pro'
```

### Utilisation Frontend

```tsx
import { getTranslation } from '@/lib/translatable'

interface Plan {
  nameI18n: { fr: string, en: string }
  descriptionI18n: { fr: string, en: string }
}

export function PlanCard({ plan }: { plan: Plan }) {
  const { i18n } = useTranslation()

  return (
    <div>
      <h3>{getTranslation(plan.nameI18n, i18n.language as 'fr' | 'en')}</h3>
      <p>{getTranslation(plan.descriptionI18n, i18n.language as 'fr' | 'en')}</p>
    </div>
  )
}
```

## Full-Text Search multi-langue

Les triggers PostgreSQL indexent automatiquement FR + EN :

```sql
CREATE OR REPLACE FUNCTION plans_search_trigger() RETURNS trigger AS $$
BEGIN
  NEW.search_vector :=
    setweight(to_tsvector('french', COALESCE(NEW.name_i18n->>'fr', '')), 'A') ||
    setweight(to_tsvector('english', COALESCE(NEW.name_i18n->>'en', '')), 'A') ||
    setweight(to_tsvector('french', COALESCE(NEW.description_i18n->>'fr', '')), 'C') ||
    setweight(to_tsvector('english', COALESCE(NEW.description_i18n->>'en', '')), 'C');
  RETURN NEW;
END
$$ LANGUAGE plpgsql;
```

La recherche fonctionne dans les deux langues automatiquement.

## Utilisation

### Ajouter une nouvelle traduction statique

1. **Backend** : Ajouter dans `resources/lang/{locale}/{namespace}.json`

```json
// resources/lang/fr/common.json
{
  "new_key": "Nouvelle traduction"
}

// resources/lang/en/common.json
{
  "new_key": "New translation"
}
```

2. **Frontend** : Ajouter dans `inertia/lib/i18n.ts`

```typescript
const resources = {
  fr: {
    common: {
      new_key: 'Nouvelle traduction',
    }
  },
  en: {
    common: {
      new_key: 'New translation',
    }
  }
}
```

3. **Utiliser** :

```typescript
// Backend
const text = i18n.t('common.new_key')

// Frontend
const text = t('common.new_key')
```

### Ajouter une nouvelle table avec champs traduisibles

1. **Migration** : Utiliser colonnes `_i18n`

```typescript
table.jsonb('name_i18n').notNullable()
table.jsonb('description_i18n').nullable()

// Trigger Full-Text Search
this.schema.raw(`
  CREATE OR REPLACE FUNCTION ${this.tableName}_search_trigger() RETURNS trigger AS $$
  BEGIN
    NEW.search_vector :=
      setweight(to_tsvector('french', COALESCE(NEW.name_i18n->>'fr', '')), 'A') ||
      setweight(to_tsvector('english', COALESCE(NEW.name_i18n->>'en', '')), 'A');
    RETURN NEW;
  END
  $$ LANGUAGE plpgsql;
`)
```

2. **Modèle** : Utiliser `TranslatableField`

```typescript
import type { TranslatableField } from '#shared/helpers/translatable'

@column({
  prepare: (value: TranslatableField) => JSON.stringify(value),
  consume: (value: string | TranslatableField) =>
    typeof value === 'string' ? JSON.parse(value) : value,
})
declare nameI18n: TranslatableField
```

3. **Tests** : Fournir les deux traductions

```typescript
await repository.create({
  nameI18n: { fr: 'Nom FR', en: 'Name EN' },
  descriptionI18n: { fr: 'Description FR', en: 'Description EN' },
})
```

### Changer la langue utilisateur

**Frontend** :
```typescript
import { useTranslation } from 'react-i18next'

const { i18n } = useTranslation()
i18n.changeLanguage('en')
document.cookie = `locale=en; path=/; max-age=31536000`
```

**Backend (query param)** :
```
https://app.com/plans?locale=en
```

## Bonnes pratiques

1. ✅ **Toujours fournir FR et EN** pour les champs traduisibles
2. ✅ **Utiliser `getTranslation()`** pour récupérer la bonne traduction
3. ✅ **Grouper les traductions** par namespace (`common`, `auth`, etc.)
4. ✅ **Ne pas dupliquer** : Utiliser i18n pour l'interface, JSON pour le contenu
5. ✅ **Tester les deux langues** dans les tests
6. ❌ **Ne jamais hardcoder** les textes affichables
7. ❌ **Ne pas oublier** les triggers Full-Text Search

## Ajouter une 3ème langue

Pour ajouter l'espagnol par exemple :

1. **Config backend** : `config/i18n.ts`
```typescript
supportedLocales: ['fr', 'en', 'es']
```

2. **Fichiers traduction** : Créer `resources/lang/es/`

3. **Config frontend** : `inertia/lib/i18n.ts`
```typescript
resources: {
  es: { common: {...}, auth: {...} }
}
```

4. **Type TranslatableField** : `app/shared/helpers/translatable.ts`
```typescript
export type TranslatableField = {
  fr: string
  en: string
  es: string
}
```

5. **Migrations** : Ajouter espagnol dans triggers
```sql
setweight(to_tsvector('spanish', COALESCE(NEW.name_i18n->>'es', '')), 'A')
```

6. **LanguageSelector** : Ajouter le drapeau 🇪🇸

---

**Note** : Le système est conçu pour être extensible. L'ajout de nouvelles langues nécessite de mettre à jour tous les points ci-dessus.
